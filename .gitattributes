# Auto detect text files and perform LF normalization
* text=auto

#Lionels part:
import calendar
from datetime import datetime

class Schedule:
    def __init__(self):
        self.shifts_data = {} # Will store the shifts data

    def update_shift(self, caregivers):
        """Assign shifts based on caregiver availability and preferences."""
        self.shifts_data.clear() #Clear the existing shift data
        shifts = ["7AM - 1PM", "1PM - 7PM", "7PM - 7AM"]
        days_in_month = range(1, 32) # Have to define the fays in a month. Going to use 31 days

        for day in days_in_month:
            for shift_time in shifts:
                available_caregivers = [cg for cg in caregivers if self.is_available(cg, shift_time)] #Find caregivers who are available for the shift
                if available_caregivers:
                    available_caregivers.sort(key=lambda cg: self.get_preference(cg, shift_time), reverse=True) #Sort caregivers by their preference for the shift
                    caregiver = available_caregivers[0]
                    self.shifts_data.setdefault(day, []).append((caregiver.name, shift_time))

    def is_available(self, caregiver, shift_time):
        """Check if caregiver is available for a shift.""" # Check if the caregiver is available for the shift time
        for shift in caregiver.shifts:
            if shift_time in shift and caregiver.shifts[shift] != "Unavailable":
                return True
        return False

    def get_preffered_shifts(self, caregivers, shift_time):
        """Get caregivers who prefer a shift.""" # Have to check if the caregiver prefers the shift
        for shift in caregivers.shifts:
            if shift["shift"] == shift_time:
                return shift ["availability"] == "Preferred"
        return False

    def generate_calendar_view(self): # Initialize the calendar string with the month and year

        """Generate a calendar view of the shifts.""" # Get the current month and year
        current_month = datetime.now().month 
        current_year = datetime.now().year
        cal = calendar.Calendar(calendar.SUNDAY)
        cal_month = cal.monthdayscalendar(current_year, current_month) # Get days of the current month in a matrix format

        calendar_str = f"{calendar.month_name[current_month]} {current_year}\n"
        calendar_str += "Sun  Mon  Tue  Wed  Thu  Fri  Sat\n"
        for week in cal_month:
            week_str = ""
            for day in week: # Loop through the days of the week
                if day != 0: 
                    shifts_for_day = "\n".join([f"{caregiver}: {shift}" for caregiver, shift in self.shifts_data.get(day, [])]) # Get the shifts for the day
                    if shifts_for_day:
                        week_str += f"{day:2} ({shifts_for_day})  "
                    else:
                        week_str += f"{day:2} (No shifts)  " # If there are no shifts for the day
                else:
                    week_str += "    " # Add the spaces for the days that are not in the month
            
            calendar_str += week_str + "\n"

        return calendar_str # Return the calendar string







#Maryanne's part:








#Inaya Siddiqi's part: 
class PayCalculator:
    def __init__(self, caregivers, schedule):
        self.caregivers = caregivers  # this is the list of all caregivers
        self.schedule = schedule  # this is the schedule object with shifts
        self.hourly_rate = 20  # the rate for paid caregivers is $20/hour

    def calculate_weekly_pay(self):
        """calculate weekly pay for caregivers"""
        pay_data = {}  # this will store pay for each caregiver

        # go through the schedule and calculate hours worked
        for day, shifts in self.schedule.shifts_data.items():  # loop through each day in the schedule
            for caregiver_name, shift_time in shifts:  # loop through each shift in the day
                # find the caregiver in the list
                caregiver = next((cg for cg in self.caregivers if cg["name"] == caregiver_name), None)
                if caregiver:
                    # add 6 hours (because each shift is 6 hours long)
                    pay_data[caregiver_name] = pay_data.get(caregiver_name, 0) + 6

        # multiply the total hours by the hourly rate to get pay
        for caregiver_name in pay_data:
            pay_data[caregiver_name] *= self.hourly_rate  # this converts hours into dollars

        return pay_data  # return the pay data for all caregivers

    def generate_pay_report(self):
        """make a simple pay report"""
        weekly_pay = self.calculate_weekly_pay()  # get the pay data
        report = "Weekly Pay Report:\n"  # start the report
        total = 0  # to track the total pay for all caregivers

        # go through each caregiver and add their pay to the report
        for name, pay in weekly_pay.items():
            report += f"{name}: ${pay:.2f}\n"  # add each caregiver's pay to the report
            total += pay  # add to the total

        # add the total pay to the report
        report += f"\nTotal Weekly Pay: ${total:.2f}"
        return report  # return the full report


#Running it (all of us):
if __name__ == "__main__":
    schedule = Schedule()  # make a schedule object to handle shifts
    app = CaregiverSchedulingApp(schedule)  # create the main app and pass the schedule to it

    # add some fake caregivers for testing the program
    app.caregivers = [
        {
            "name": "Alice",  # caregiver's name
            "phone": "1234567890",  # their phone number
            "email": "alice@example.com",  # their email
            "availability": {"7AM - 1PM": "Preferred"}  # alice prefers morning shifts
        },
        {
            "name": "Bob",  # another caregiver
            "phone": "0987654321",  # bob's phone number
            "email": "bob@example.com",  # bob's email
            "availability": {"1PM - 7PM": "Available"}  # bob is available for afternoon shifts
        }
    ]

    # update the schedule with the caregivers' availability
    schedule.update_shift(app.caregivers)

    # run the app to show the GUI
    app.mainloop()

