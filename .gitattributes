# Auto detect text files and perform LF normalization
* text=auto

#Lionels part:
import calendar
from datetime import datetime

class Schedule:
    def __init__(self):
        self.shifts_data = {} # Will store the shifts data

    def update_shift(self, caregivers, year, month):
        """Assign shifts based on caregiver availability and preferences."""
        self.shifts_data.clear() # Clear the existing shift data
        shifts = ["7AM - 1PM", "1PM - 7PM", "7PM - 7AM"]
        days_in_month = range(1, calendar.monthrange(year, month)[1] + 1) # Have to define the days in a month.

        for day in days_in_month:
            for shift_time in shifts:
                available_caregivers = [cg for cg in caregivers if self.is_available(cg, shift_time)] #Find caregivers who are available for the shift
                if available_caregivers:
                    available_caregivers.sort(key=lambda cg: self.get_preference(cg, shift_time), reverse=True) #Sort caregivers by their preference for the shift
                    caregiver = available_caregivers[0]
                    self.shifts_data.setdefault(day, []).append((caregiver["name"], shift_time))

    def is_available(self, caregiver, shift_time):
        """Check if caregiver is available for a shift.""" # Check if the caregiver is available for the shift time
        return shift_time in caregiver["availability"] and caregiver["availability"][shift_time] != "Unavailable"

    def get_preference(self, caregiver, shift_time):
        """Get caregivers who prefer a shift.""" # Have to check if the caregiver prefers the shift
        return caregiver["availability"].get(shift_time, "Unavailable") == "Preferred"

    def generate_calendar_view(self): # Initialize the calendar string with the month and year

        """Generate a calendar view of the shifts.""" # Get the current month and year
        current_month = datetime.now().month 
        current_year = datetime.now().year
        cal = calendar.Calendar(calendar.SUNDAY)
        cal_month = cal.monthdayscalendar(current_year, current_month) # Get days of the current month in a matrix format

        calendar_str = f"{calendar.month_name[current_month]} {current_year}\n"
        calendar_str += "Sun  Mon  Tue  Wed  Thu  Fri  Sat\n"
        for week in cal_month:
            week_str = ""
            for day in week: # Loop through the days of the week
                if day != 0: 
                    shifts_for_day = "\n".join([f"{caregiver}: {shift}" for caregiver, shift in self.shifts_data.get(day, [])]) # Get the shifts for the day
                    if shifts_for_day:
                        week_str += f"{day:2} ({shifts_for_day})  "
                    else:
                        week_str += f"{day:2} (No shifts)  " # If there are no shifts for the day
                else:
                    week_str += "    " # Add the spaces for the days that are not in the month
            
            calendar_str += week_str + "\n"

        return calendar_str # Return the calendar string







#Maryanne's part:
import tkinter as tk
from tkinter import ttk, messagebox

# scheduling class
class CaregiverSchedulingApp(tk.Tk):
    def __init__(self, schedule):
        super().__init__()
        self.title("Caregiver Scheduling App")
        self.geometry("900x700")

        self.schedule = schedule
        self.caregivers = []  # List of caregiver dictionaries

        self.create_widgets()

    def create_widgets(self):
        ttk.Label(self, text="~ Caregiver Scheduling System ~", font=("Arial", 16)).pack(pady=10)

        # Add Caregiver Section
        add_frame = ttk.Frame(self)
        add_frame.pack()
        # For the name
        ttk.Label(add_frame, text="Name:").pack()
        self.name_var = tk.StringVar()
        ttk.Entry(add_frame, textvariable=self.name_var).pack()
        # For the Phone
        ttk.Label(add_frame, text="Phone:").pack()
        self.phone_var = tk.StringVar()
        # For the Email
        ttk.Entry(add_frame, textvariable=self.phone_var).pack()
        ttk.Label(add_frame, text="Email:").pack()
        self.email_var = tk.StringVar()
        ttk.Entry(add_frame, textvariable=self.email_var).pack()
        ttk.Button(add_frame, text="Add Caregiver", command=self.add_caregiver).pack(padx=10) # To add caregiver info

        # Calendar View Button
        ttk.Button(self, text="Open Calendar View", command=self.show_calendar_view).pack(pady=10)

        caregiver_frame = ttk.Frame(self)
        caregiver_frame.pack(pady=10)

        ttk.Label(caregiver_frame, text="Caregivers", font=("Arial", 12)).pack(pady=3)
         
        header_frame = ttk.Frame(caregiver_frame)
        header_frame.pack()

        ttk.Label(header_frame, text="Name", font=("Arial", 12, "bold")).pack(side=tk.LEFT, padx=10)
        ttk.Label(header_frame, text="Phone", font=("Arial", 12, "bold")).pack(side=tk.LEFT, padx=10)
        ttk.Label(header_frame, text="Email", font=("Arial", 12, "bold")).pack(side=tk.LEFT, padx=10)

        self.caregiver_labels = []  
        self.update_caregiver_list(caregiver_frame)

    def add_caregiver(self):
        name = self.name_var.get().strip() 
        phone = self.phone_var.get().strip()
        email = self.email_var.get().strip()

        if name and phone and email:
            self.caregivers.append({"name": name, "phone": phone, "email": email, "availability": {}})
            self.update_caregiver_list()
            self.clear_inputs()
        else:
            messagebox.showwarning("Input Error", "All fields are required!") # input validation to make sure all the fields are entered

    def update_caregiver_list(self, caregiver_frame=None):
        for label in self.caregiver_labels:
            label.destroy()

        self.caregiver_labels = []

        if caregiver_frame:
            for caregiver in self.caregivers:
                caregiver_info = f"Name: {caregiver['name']} | Phone: {caregiver['phone']} | Email: {caregiver['email']}"
                caregiver_row_frame = ttk.Frame(caregiver_frame)
                caregiver_row_frame.pack(pady=5)

                # labels for each column in caregiver row
                ttk.Label(caregiver_row_frame, text=caregiver['name'], font=("Arial", 10)).pack(side=tk.LEFT, padx=10)
                ttk.Label(caregiver_row_frame, text=caregiver['phone'], font=("Arial", 10)).pack(side=tk.LEFT, padx=10)
                ttk.Label(caregiver_row_frame, text=caregiver['email'], font=("Arial", 10)).pack(side=tk.LEFT, padx=10)

                self.caregiver_labels.append(caregiver_row_frame) 

    def clear_inputs(self): # clear inputs
        self.name_var.set("")
        self.phone_var.set("")
        self.email_var.set("")

    def show_calendar_view(self):
        calendar_view = self.schedule.generate_calendar_view()
        # *ChatGPT, response to the prompt "How can I create a calendar view in a tkinter application that displays schedule in a separate window?" OpenAI, November 22, 2024.*
        calendar_window = tk.Toplevel(self)
        calendar_window.title("Calendar View")
        text_widget = tk.Text(calendar_window, wrap=tk.WORD)
        text_widget.insert(tk.END, calendar_view)
        text_widget.pack()







#Inaya Siddiqi's part: 
class PayCalculator:
    def __init__(self, caregivers, schedule):
        self.caregivers = caregivers  # this is the list of all caregivers
        self.schedule = schedule  # this is the schedule object with shifts
        self.hourly_rate = 20  # the rate for paid caregivers is $20/hour

    def calculate_weekly_pay(self):
        """calculate weekly pay for caregivers"""
        pay_data = {}  # this will store pay for each caregiver

        # go through the schedule and calculate hours worked
        for day, shifts in self.schedule.shifts_data.items():  # loop through each day in the schedule
            for caregiver_name, shift_time in shifts:  # loop through each shift in the day
                # find the caregiver in the list
                caregiver = next((cg for cg in self.caregivers if cg["name"] == caregiver_name), None)
                if caregiver:
                    # add 6 hours (because each shift is 6 hours long)
                    pay_data[caregiver_name] = pay_data.get(caregiver_name, 0) + 6

        # multiply the total hours by the hourly rate to get pay
        for caregiver_name in pay_data:
            pay_data[caregiver_name] *= self.hourly_rate  # this converts hours into dollars

        return pay_data  # return the pay data for all caregivers

    def generate_pay_report(self):
        """make a simple pay report"""
        weekly_pay = self.calculate_weekly_pay()  # get the pay data
        report = "Weekly Pay Report:\n"  # start the report
        total = 0  # to track the total pay for all caregivers

        # go through each caregiver and add their pay to the report
        for name, pay in weekly_pay.items():
            report += f"{name}: ${pay:.2f}\n"  # add each caregiver's pay to the report
            total += pay  # add to the total

        # add the total pay to the report
        report += f"\nTotal Weekly Pay: ${total:.2f}"
        return report  # return the full report


#Running it (all of us):
if __name__ == "__main__":
    schedule = Schedule()  # make a schedule object to handle shifts
    app = CaregiverSchedulingApp(schedule)  # create the main app and pass the schedule to it

    # add some fake caregivers for testing the program
    app.caregivers = [
        {
            "name": "Alice",  # caregiver's name
            "phone": "1234567890",  # their phone number
            "email": "alice@example.com",  # their email
            "availability": {"7AM - 1PM": "Preferred"}  # alice prefers morning shifts
        },
        {
            "name": "Bob",  # another caregiver
            "phone": "0987654321",  # bob's phone number
            "email": "bob@example.com",  # bob's email
            "availability": {"1PM - 7PM": "Available"}  # bob is available for afternoon shifts
        }
    ]

    # update the schedule with the caregivers' availability
    schedule.update_shift(app.caregivers)

    # run the app to show the GUI
    app.mainloop()

